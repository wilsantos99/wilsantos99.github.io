{"version":3,"sources":["src/qr-scanner.js","index.js"],"names":["mediaDevices","enumerateDevices","then","kind","catch","DEFAULT_CANVAS_SIZE","$video","$canvas","createElement","_onDecode","_paused","_active","width","height","_sourceRect","x","_onCanPlay","bind","_onPlay","_onVisibilityChange","addEventListener","document","_qrWorker","Worker","QrScanner","WORKER_PATH","removeEventListener","stop","postMessage","type","Promise","resolve","window","location","protocol","console","warn","hidden","clearTimeout","_offTimeout","srcObject","play","facingMode","_getCameraStream","stream","_setVideoMirror","e","pause","setTimeout","track","imageOrFileOrUrl","sourceRect","worker","canvas","fixedCanvasSize","alsoTryWithoutSourceRect","createdNewWorker","promise","reject","timeout","onMessage","onError","data","event","_loadImage","image","imageData","buffer","scanImage","finally","red","green","blue","useIntegerApproximation","inversionMode","_updateSourceRect","_scanFrame","start","videoHeight","sourceRectSize","videoWidth","y","paused","ended","requestAnimationFrame","error","exact","min","constraintsToTry","forEach","constraint","_getMatchingCameraStream","length","navigator","getUserMedia","video","shift","style","transform","context","sourceRectWidth","sourceRectHeight","alpha","imageSmoothingEnabled","drawImage","sourceRectX","sourceRectY","getImageData","HTMLCanvasElement","HTMLVideoElement","ImageBitmap","OffscreenCanvas","Image","_awaitImageLoad","File","URL","src","createObjectURL","revokeObjectURL","complete","naturalWidth","onLoad","getElementById","qrScanner","result","log"],"mappings":"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","file":"qrcode-reader.5c097017.js","sourceRoot":"..","sourcesContent":["export default class QrScanner {\n    /* async */\n    static hasCamera() {\n        // note that enumerateDevices can always be called and does not prompt the user for permission. However, device\n        // labels are only readable if served via https and an active media stream exists or permanent permission is\n        // given. That doesn't matter for us though as we don't require labels.\n        return navigator.mediaDevices.enumerateDevices()\n            .then(devices => devices.some(device => device.kind === 'videoinput'))\n            .catch(() => false);\n    }\n\n    constructor(video, onDecode, canvasSize = QrScanner.DEFAULT_CANVAS_SIZE) {\n        this.$video = video;\n        this.$canvas = document.createElement('canvas');\n        this._onDecode = onDecode;\n        this._active = false;\n        this._paused = false;\n\n        this.$canvas.width = canvasSize;\n        this.$canvas.height = canvasSize;\n        this._sourceRect = {\n            x: 0,\n            y: 0,\n            width: canvasSize,\n            height: canvasSize\n        };\n\n        this._onCanPlay = this._onCanPlay.bind(this);\n        this._onPlay = this._onPlay.bind(this);\n        this._onVisibilityChange = this._onVisibilityChange.bind(this);\n\n        this.$video.addEventListener('canplay', this._onCanPlay);\n        this.$video.addEventListener('play', this._onPlay);\n        document.addEventListener('visibilitychange', this._onVisibilityChange);\n\n        this._qrWorker = new Worker(QrScanner.WORKER_PATH);\n    }\n\n    destroy() {\n        this.$video.removeEventListener('canplay', this._onCanPlay);\n        this.$video.removeEventListener('play', this._onPlay);\n        document.removeEventListener('visibilitychange', this._onVisibilityChange);\n\n        this.stop();\n        this._qrWorker.postMessage({\n            type: 'close'\n        });\n    }\n\n    /* async */\n    start() {\n        if (this._active && !this._paused) {\n            return Promise.resolve();\n        }\n        if (window.location.protocol !== 'https:') {\n            // warn but try starting the camera anyways\n            console.warn('The camera stream is only accessible if the page is transferred via https.');\n        }\n        this._active = true;\n        this._paused = false;\n        if (document.hidden) {\n            // camera will be started as soon as tab is in foreground\n            return Promise.resolve();\n        }\n        clearTimeout(this._offTimeout);\n        this._offTimeout = null;\n        if (this.$video.srcObject) {\n            // camera stream already/still set\n            this.$video.play();\n            return Promise.resolve();\n        }\n\n        let facingMode = 'environment';\n        return this._getCameraStream('environment', true)\n            .catch(() => {\n                // we (probably) don't have an environment camera\n                facingMode = 'user';\n                return this._getCameraStream(); // throws if camera is not accessible (e.g. due to not https)\n            })\n            .then(stream => {\n                this.$video.srcObject = stream;\n                this._setVideoMirror(facingMode);\n            })\n            .catch(e => {\n                this._active = false;\n                throw e;\n            });\n    }\n\n    stop() {\n        this.pause();\n        this._active = false;\n    }\n\n    pause() {\n        this._paused = true;\n        if (!this._active) {\n            return;\n        }\n        this.$video.pause();\n        if (this._offTimeout) {\n            return;\n        }\n        this._offTimeout = setTimeout(() => {\n            const track = this.$video.srcObject && this.$video.srcObject.getTracks()[0];\n            if (!track) return;\n            track.stop();\n            this.$video.srcObject = null;\n            this._offTimeout = null;\n        }, 300);\n    }\n\n    /* async */\n    static scanImage(imageOrFileOrUrl, sourceRect=null, worker=null, canvas=null, fixedCanvasSize=false,\n                     alsoTryWithoutSourceRect=false) {\n        let createdNewWorker = false;\n        let promise = new Promise((resolve, reject) => {\n            if (!worker) {\n                worker = new Worker(QrScanner.WORKER_PATH);\n                createdNewWorker = true;\n                worker.postMessage({ type: 'inversionMode', data: 'both' }); // scan inverted color qr codes too\n            }\n            let timeout, onMessage, onError;\n            onMessage = event => {\n                if (event.data.type !== 'qrResult') {\n                    return;\n                }\n                worker.removeEventListener('message', onMessage);\n                worker.removeEventListener('error', onError);\n                clearTimeout(timeout);\n                if (event.data.data !== null) {\n                    resolve(event.data.data);\n                } else {\n                    reject('QR code not found.');\n                }\n            };\n            onError = (e) => {\n                worker.removeEventListener('message', onMessage);\n                worker.removeEventListener('error', onError);\n                clearTimeout(timeout);\n                const errorMessage = !e ? 'Unknown Error' : (e.message || e);\n                reject('Scanner error: ' + errorMessage);\n            };\n            worker.addEventListener('message', onMessage);\n            worker.addEventListener('error', onError);\n            timeout = setTimeout(() => onError('timeout'), 3000);\n            QrScanner._loadImage(imageOrFileOrUrl).then(image => {\n                const imageData = QrScanner._getImageData(image, sourceRect, canvas, fixedCanvasSize);\n                worker.postMessage({\n                    type: 'decode',\n                    data: imageData\n                }, [imageData.data.buffer]);\n            }).catch(onError);\n        });\n\n        if (sourceRect && alsoTryWithoutSourceRect) {\n            promise = promise.catch(() => QrScanner.scanImage(imageOrFileOrUrl, null, worker, canvas, fixedCanvasSize));\n        }\n\n        promise = promise.finally(() => {\n            if (!createdNewWorker) return;\n            worker.postMessage({\n                type: 'close'\n            });\n        });\n\n        return promise;\n    }\n\n    setGrayscaleWeights(red, green, blue, useIntegerApproximation = true) {\n        this._qrWorker.postMessage({\n            type: 'grayscaleWeights',\n            data: { red, green, blue, useIntegerApproximation }\n        });\n    }\n\n    setInversionMode(inversionMode) {\n        this._qrWorker.postMessage({\n            type: 'inversionMode',\n            data: inversionMode\n        });\n    }\n\n    _onCanPlay() {\n        this._updateSourceRect();\n        this.$video.play();\n    }\n\n    _onPlay() {\n        this._updateSourceRect();\n        this._scanFrame();\n    }\n\n    _onVisibilityChange() {\n        if (document.hidden) {\n            this.pause();\n        } else if (this._active) {\n            this.start();\n        }\n    }\n\n    _updateSourceRect() {\n        const smallestDimension = Math.min(this.$video.videoWidth, this.$video.videoHeight);\n        const sourceRectSize = Math.round(2 / 3 * smallestDimension);\n        this._sourceRect.width = this._sourceRect.height = sourceRectSize;\n        this._sourceRect.x = (this.$video.videoWidth - sourceRectSize) / 2;\n        this._sourceRect.y = (this.$video.videoHeight - sourceRectSize) / 2;\n    }\n\n    _scanFrame() {\n        if (!this._active || this.$video.paused || this.$video.ended) return false;\n        // using requestAnimationFrame to avoid scanning if tab is in background\n        requestAnimationFrame(() => {\n            QrScanner.scanImage(this.$video, this._sourceRect, this._qrWorker, this.$canvas, true)\n                .then(this._onDecode, error => {\n                    if (this._active && error !== 'QR code not found.') {\n                        console.error(error);\n                    }\n                })\n                .then(() => this._scanFrame());\n        });\n    }\n\n    _getCameraStream(facingMode, exact = false) {\n        const constraintsToTry = [{\n            width: { min: 1024 }\n        }, {\n            width: { min: 768 }\n        }, {}];\n\n        if (facingMode) {\n            if (exact) {\n                facingMode = { exact: facingMode };\n            }\n            constraintsToTry.forEach(constraint => constraint.facingMode = facingMode);\n        }\n        return this._getMatchingCameraStream(constraintsToTry);\n    }\n\n    _getMatchingCameraStream(constraintsToTry) {\n        if (constraintsToTry.length === 0) {\n            return Promise.reject('Camera not found.');\n        }\n        return navigator.mediaDevices.getUserMedia({\n            video: constraintsToTry.shift()\n        }).catch(() => this._getMatchingCameraStream(constraintsToTry));\n    }\n\n    _setVideoMirror(facingMode) {\n        // in user facing mode mirror the video to make it easier for the user to position the QR code\n        const scaleFactor = facingMode==='user'? -1 : 1;\n        this.$video.style.transform = 'scaleX(' + scaleFactor + ')';\n    }\n\n    static _getImageData(image, sourceRect=null, canvas=null, fixedCanvasSize=false) {\n        canvas = canvas || document.createElement('canvas');\n        const sourceRectX = sourceRect && sourceRect.x? sourceRect.x : 0;\n        const sourceRectY = sourceRect && sourceRect.y? sourceRect.y : 0;\n        const sourceRectWidth = sourceRect && sourceRect.width? sourceRect.width : image.width || image.videoWidth;\n        const sourceRectHeight = sourceRect && sourceRect.height? sourceRect.height : image.height || image.videoHeight;\n        if (!fixedCanvasSize && (canvas.width !== sourceRectWidth || canvas.height !== sourceRectHeight)) {\n            canvas.width = sourceRectWidth;\n            canvas.height = sourceRectHeight;\n        }\n        const context = canvas.getContext('2d', { alpha: false });\n        context.imageSmoothingEnabled = false; // gives less blurry images\n        context.drawImage(image, sourceRectX, sourceRectY, sourceRectWidth, sourceRectHeight, 0, 0, canvas.width, canvas.height);\n        return context.getImageData(0, 0, canvas.width, canvas.height);\n    }\n\n    /* async */\n    static _loadImage(imageOrFileOrUrl) {\n        if (imageOrFileOrUrl instanceof HTMLCanvasElement || imageOrFileOrUrl instanceof HTMLVideoElement\n            || window.ImageBitmap && imageOrFileOrUrl instanceof window.ImageBitmap\n            || window.OffscreenCanvas && imageOrFileOrUrl instanceof window.OffscreenCanvas) {\n            return Promise.resolve(imageOrFileOrUrl);\n        } else if (imageOrFileOrUrl instanceof Image) {\n            return QrScanner._awaitImageLoad(imageOrFileOrUrl).then(() => imageOrFileOrUrl);\n        } else if (imageOrFileOrUrl instanceof File || imageOrFileOrUrl instanceof URL\n            ||  typeof(imageOrFileOrUrl)==='string') {\n            const image = new Image();\n            if (imageOrFileOrUrl instanceof File) {\n                image.src = URL.createObjectURL(imageOrFileOrUrl);\n            } else {\n                image.src = imageOrFileOrUrl;\n            }\n            return QrScanner._awaitImageLoad(image).then(() => {\n                if (imageOrFileOrUrl instanceof File) {\n                    URL.revokeObjectURL(image.src);\n                }\n                return image;\n            });\n        } else {\n            return Promise.reject('Unsupported image type.');\n        }\n    }\n\n    /* async */\n    static _awaitImageLoad(image) {\n        return new Promise((resolve, reject) => {\n            if (image.complete && image.naturalWidth!==0) {\n                // already loaded\n                resolve();\n            } else {\n                let onLoad, onError;\n                onLoad = () => {\n                    image.removeEventListener('load', onLoad);\n                    image.removeEventListener('error', onError);\n                    resolve();\n                };\n                onError = () => {\n                    image.removeEventListener('load', onLoad);\n                    image.removeEventListener('error', onError);\n                    reject('Image load error');\n                };\n                image.addEventListener('load', onLoad);\n                image.addEventListener('error', onError);\n            }\n        });\n    }\n}\nQrScanner.DEFAULT_CANVAS_SIZE = 400;\nQrScanner.WORKER_PATH = 'qr-scanner-worker.min.js';\n","import QrScanner from \"qr-scanner\";\n\nconst video = document.getElementById(\"preview\");\n\nconst qrScanner = new QrScanner(video, result => console.log(result));"]}